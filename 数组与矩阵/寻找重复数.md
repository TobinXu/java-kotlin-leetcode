给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例 1:

输入: [1,3,4,2,2]
输出: 2
示例 2:

输入: [3,1,3,4,2]
输出: 3
说明：

不能更改原数组（假设数组是只读的）。
只能使用额外的 O(1) 的空间。
时间复杂度小于 O(n2) 。
数组中只有一个重复的数字，但它可能不止重复出现一次。

二分查找除了对索引二分，还有值域二分
数组元素肯定是 1 到 n 中的某一个，出现的位置是不定的，但值域是一个确定的区间。
二分查找有两种
对索引二分，一般用于有序数组中找出元素，有序数组中，索引的大小可以反映值的大小，因此对索引二分即可。
对值域二分。重复数落在 [1, n] ，可以对 [1, n] 这个值域二分查找。
mid = (1 + n) / 2，重复数要么落在 [1, mid] ， 要么落在 [mid + 1, n]
遍历原数组，统计小于等于 mid 的元素的个数，记为 k
如果 k > mid，说明有超过 mid 个数的值落在区间 [1, mid] ，但该区间最多只能有 mid 个“坑”，说明重复的数落在 [1, mid]。
相反，如果 k <= mid ，则说明重复数落在 [mid + 1, n]
继续对重复数所处的区间二分，直到区间闭合（左界=右界），重复数就找到了。
时间复杂度：二分法O(logN)，但二分法内部遍历了一次数组O(N)，综合为 O(NlogN)
空间复杂度：O(1)

function findDuplicate(nums) {
  let low = 1, high = nums.length - 1; // 数组想的范围1到n
  while (low < high) { // 在循环中缩小区间，区间闭合循环结束
    let mid = (low + high) >> 1 // 求中间值
    let count = 0;
    for (let i =0; i < nums.length; i++) {
      if (nums[i] <= mid) count++; // 统计小于等于mid的数
    }
    // 重复数落在[1, mid]
    if (count > mid) {
      high = mid; // 区间收缩
    } else {
      low = mid + 1;
    }
  } 
  return low;
}

快慢指针法
分析这个数组的特点，索引从 0～n0～n ，数组项的范围是 1～n1～n 。可见，数组元素的范围，在 索引的范围内，值可以当索引使。
比如，nums 数组：[4, 3, 1, 2, 2][4,3,1,2,2]
以 nums[0] 的值 4 作为索引，去到 nums[4]
以 nums[4] 的值 2 作为索引，去到 nums[2]
以 nums[2] 的值 1 作为索引，去到 nums[1]……
从一项指向另一项，抽象成一个链表：4 -> 2 -> 1 -> 3 -> 2，又指回了 2——链表有环。

题目说数组必存在重复数，且元素数值正好在索引范围内，所以它肯定可以抽象为有环链表。
题目等价为：求该有环链表的入环口，因为入环口的元素就是重复的链表节点值。

function findDuplicate(nums) {
  let slow = 0, fast = 0; // slow跳一步，fast跳两步
  while (true) {
    slow = nums[slow]; // 以新项作为索引
    fast = nums[nums[fast]] // 以新项作为索引而得到的新新项作为索引
    if (slow === fast) {// 指针首次相遇
      fast = 0; 让快指针回到起点
      while (true) { // 开启新循环
        if (slow === fast) { // 如果再次相遇，就肯定是入口处
          return slow; // 返回入口，即重复的数
        }
        slow = nums[slow]; // 两个指针每次都进一步
        fast = nums[fast];
      }
    } 
  }
}